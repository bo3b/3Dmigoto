;------------------------------------------------------------------------------------------------------
; Logging options.
; Comment line or set value to 0 for no logging.
;------------------------------------------------------------------------------------------------------
[Logging]

; Log all API usage
calls=0

; Log Input key actions
input=0

; Super verbose massive log
debug=0

; Unbuffered logging to avoid missing anything at file end
unbuffered=0

; Force the CPU affinity to use only a single CPU for debugging multi-threaded
force_cpu_affinity=0

; Log NVAPI convergence modifications
convergence=0
; Log NVAPI separation modifications
separation=0


; ------------------------------------------------------------------------------------------------------
; Default constants to pass directly to shaders as IniParams
; ------------------------------------------------------------------------------------------------------
[Constants]
; x sets depth for HUD items that are not automatically adjusted. 0 is screen
; depth, 1 is max, negative to pop out
x = 0.9
; y sets the minimum depth in world coordinates for any HUD item that is
; automatically adjsuted. Trade off to prevent crosshair lining up on nearby
; foliage at the expense of being rendered behind scenery.
y = 0.3
; z sets the minimap depth. Use -1 to automatically adjust it from the depth
; buffer, but that is disabled by default as it can be distracting as the
; weapon tends to move in front of it while running.
z = 0.9

; Other IniParams used internally in the fix:
; w - indictes that ResourceZBuffer is valid
; x1 - render target width, for the sun/moon glow + reflection shader
; y1 - render target height, for the sun/moon glow + reflection shader
; z1 - screen width, for render target size filtering
; w1 - screen height, for render target size filtering
; x2 - used for texture filtering
; y2 - used for partner shader filtering for text
; z2 - holds the number of vertices being drawn for text
; w2 - indicates that the camera HUD or mission text is being drawn
; x3 - indicates that the repair tool has been drawn this frame, for the flame fix
; y3 - indicates LMB is held down to switch between two repair tool flame adjustments
; z3 - texture filtering for repair tool sparks
; w3 - indicates that the climbing rope is being drawn

;------------------------------------------------------------------------------------------------------
; Custom settings override for any of [convergence, separation, x, y, z, w]
;
; Four types are supported - by default the bindings will simply load the
; configured settings, but type=hold can be specified to have a preset
; active while the button is held, type=toggle can be used to make a simple
; on/off toggle, and type=cycle can be used to cycle between several presets.
;
; Delays (type=hold only) and linear or cosine trasition periods (any key type)
; can be used to better synchonrise setting changes to the game's animations,
; or to smoothly adjust UI elements over a short period of time.
;
; Key bindings: For A-Z and 0-9 on the number row, just use that single
; character. For everything else (including mouse buttons), use the virtual key
; name (with or without the VK_ prefix) or hex code from this article:
; http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
;
; Keys can also be from XBox controllers using:
;   XB_LEFT_TRIGGER, XB_RIGHT_TRIGGER,
;   XB_LEFT_SHOULDER, XB_RIGHT_SHOULDER,
;   XB_LEFT_THUMB, XB_RIGHT_THUMB,
;   XB_DPAD_UP, XB_DPAD_DOWN, XB_DPAD_LEFT, XB_DPAD_RIGHT,
;   XB_A, XB_B, XB_X, XB_Y, XB_START, XB_BACK
; By default all attached controllers are used - to associate a binding with a
; specific controller add the controller number 1-4 to the prefix, like
; XB2_LEFT_TRIGGER, though this may be more useful for hunting than playing.
;------------------------------------------------------------------------------------------------------

; Convergence override while aiming:
[Key1]
Key=RBUTTON
Convergence=0.02
Type=hold
;delay=100
transition=300
transition_type=cosine
release_delay=150
release_transition=150
release_transition_type=cosine
; Disable convergence override when climbing rope is in frame:
condition = w3

[Key2]
Key=XB_LEFT_TRIGGER
Convergence=0.02
Type=hold
;delay=100
transition=300
transition_type=cosine
release_delay=150
release_transition=150
release_transition_type=cosine
; Disable convergence override when climbing rope is in frame:
condition = w3

;;;;;;;;;;;; CLIMBING ROPE DETECTION TO DISABLE CONVERGENCE OVERRIDE ;;;;;;;;;;;;;;

[ShaderOverrideRope]
Hash = 9394faee0e894d36
checktextureoverride = ps-t0

[TextureOverrideRope]
Hash = 3a900e80
w3 = 0

[KeyResetConvergence]
; Set default convergence from the Far Cry 4 driver profile
Key = \
Convergence = 0.3234737

;;;;;;;;;;;;;;;;;;; REPAIR TOOL FIX ;;;;;;;;;;;;;;;;;;;;;
;
[ShaderOverrideRepairToolVS]
Hash = e6e6fcf9b5002f19
; Used to detect when the repair tool is being drawn:
checktextureoverride = ps-t0

[TextureOverrideRepairTool]
Hash = 0594efed
x3 = 1

[ShaderOverrideSparksVS]
Hash = 52aed2f11227b60e
vs-t110 = ResourceZBufferLastFrame
z3 = ps-t0
[TextureOverrideRepairToolSparks]
Hash=87415528
[TextureOverrideRepairToolSparksGlow]
Hash=202a9f89

; Used to switch repair tool flame depth corrections while firing
[KeyFire]
Key = LBUTTON
type = hold
delay = 100
release_delay = 200
y3 = 1

[KeyFire2]
Key = XB_RIGHT_TRIGGER
type = hold
delay = 100
release_delay = 200
y3 = 1

;------------------------------------------------------------------------------------------------------
; Shader hunting options.
; Default setup is to use keyboard similar to Helix presets
;------------------------------------------------------------------------------------------------------
[Hunting]

; 0: Release mode is with shader hunting disabled, optimized for speed.
; 1: Hunting mode enabled
; 2: Hunting mode "soft disabled" - can be turned on via the toggle_hunting key
hunting=0

; Highlight mode of currently selected shader / rendertarget.
; "skip" = skip shader. don't render anything using the currently selected shader.
; "original" = fall back to original shader if the currently selected shader was patched.
; "pink" = make the output hot pink to make it standout.
; "mono" = disable stereo for the selected shader / rendertarget.
; "zero" = shader output is all zero. NOTE: this has a big performance impact.
marking_mode=skip

; Key bindings: For A-Z and 0-9 on the number row, just use that single
; character. For everything else (including mouse buttons), use the virtual key
; name (with or without the VK_ prefix) or hex code from this article:
; http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
;
; XBox controllers are supported using the same bindings as the [Key] sections
; (see above). If the game already uses the first controller you might try
; using the second controller for hunting with e.g. XB2_LEFT_SHOULDER

; rotate through all VISIBLE pixel shaders at the current scene.
previous_pixelshader=VK_NUMPAD1
next_pixelshader=VK_NUMPAD2
mark_pixelshader=VK_NUMPAD3

; rotate through all VISIBLE vertex shaders at the current scene.
previous_vertexshader=VK_NUMPAD4
next_vertexshader=VK_NUMPAD5
mark_vertexshader=VK_NUMPAD6

; rotate through all USED index buffers at the current scene.
previous_indexbuffer=VK_NUMPAD7
next_indexbuffer=VK_NUMPAD8
mark_indexbuffer=VK_NUMPAD9

; rotate through all USED render targets at the current scene.
previous_rendertarget=VK_DIVIDE
next_rendertarget=VK_MULTIPLY
mark_rendertarget=VK_SUBTRACT

; rotate through all VISIBLE geometry shaders at the current scene.
previous_geometryshader = <
next_geometryshader = >
mark_geometryshader = /

; rotate through all VISIBLE domain shaders at the current scene.
previous_domainshader = [
next_domainshader = ]
mark_domainshader = \

; rotate through all VISIBLE hull shaders at the current scene.
; This is disabled only because it is rarely needed
;previous_hullshader = MINUS
;next_hullshader = EQUALS
;mark_hullshader = BACKSPACE

; rotate through all USED compute shaders at the current scene.
; Disabling compute shaders may cause crashes, so these are
; not enabled by default:
;previous_computeshader = PAGE_UP
;next_computeshader = PAGE_DOWN
;mark_computeshader = HOME

; Re-enable shaders once done with hunting:
done_hunting=VK_ADD

; Screenshot as pns
take_screenshot=VK_SNAPSHOT

; reload all fixes from ShaderFixes folder
reload_fixes=VK_F10

; Key to turn hunting itself on/off.  This will also show/hide overlay.
; Hunting must be set to either 1 or 2 to enable this toggle.
toggle_hunting=VK_NUMPAD0

; Key to reload the settings from the the d3dx.ini without restarting. This can
; be the same key as reload_fixes for convenience, or a different key may be
; used to avoid resetting the ini parameters every time the shaders are
; reloaded. Note that not all settings can be reloaded, so if something doesn't
; work as expected you may still have to restart the game:
reload_config=VK_F10

; Hold this key to temporarily disable the fix - useful to quickly check what
; an effect looked like in the original game.
show_original=VK_F9

; tunable parameter to use in modified shaders as variable (StereoParams.Load(int3(1,0,0)).xyzw)
; enabling tuning results in a small performance hit because the parameter texture
;tune_enable=1
;tune_step=0.1
;tune1_up=VK_INSERT
;tune1_down=VK_DELETE
;tune2_up=X
;tune2_down=Z

; Auto-repeat key rate in events per second.
repeat_rate=10

; Dumps out the contents of each render target after every immediate draw call
; for the next frame. Takes up a large amount of space, so disabled by default.
analyse_frame=VK_F8

; Specifies options for the frame analysis feature. Options can be combined by
; separating them with a space.
;  dump_rt_jps: Dumps out render targets as JPS files. These are the easiest to
;               work with and don't take up as much space as DDS files, but they
;               are not dumped for every render target and are missing some data.
;  dump_rt_dds: Dumps out render targets as DDS files. WARNING: This option may
;               require hundreds of gigabytes and a long time! Only use it if
;               you absolutely need more information than you can get otherwise.
;               Will also dump buffer type render targets & UAVs as .buf files.
;      dump_rt: Dumps render targets as JPS files when possible, or DDS when not.
;     clear_rt: Clears each render target the first time they are used in the
;               frame. Makes it easier to see what is being drawn if the game
;               doesn't clear them, but might cause some effects not to render.
;   dump_depth: Dumps depth/stencil targets as DDS files
; dump_tex_jps: Dumps textures as JPS files
; dump_tex_dds: Dumps textures as DDS files (Same warning as for dump_rt_dds)
;               Will also dump buffer type shader resource views as .buf files.
;     dump_tex: Dumps textures as JPS files when possible, or DDS when not.
;      dump_cb: Dumps constant buffers as binary .buf files
;  dump_cb_txt: Decodes constant buffers as an array of float4s
;      dump_vb: Dumps vertex buffers as binary .buf files
;  dump_vb_txt: Decodes vertex buffers as an array of float4s
;      dump_ib: Dumps index buffers as binary .buf files
;  dump_ib_txt: Decodes index buffers
; filename_reg: Normally the draw number is the first part of the filename so
;               that the files will be sorted in the order they were used in
;               the game. Sometimes it is more desirable to examine how a
;               specific output changed through the frame and this option will
;               place the register number first in the filename to allow that.
;         mono: Dump out mono textures instead of stereo. To dump both, specify
;               'mono stereo'. If neither are specified, defaults to stereo.
; analyse_options can also be specified in [ShaderOverride*] and
; [TextureOverride*] sections to set up triggers to change the options mid-way
; through a frame analysis, either for a single draw call (default), or
; permanently (by adding the 'persist' keyword).
analyse_options =



;------------------------------------------------------------------------------------------------------
; Chain load other wrapper DLLs instead of system DLLs.
;------------------------------------------------------------------------------------------------------
[System]

;proxy_d3d9=d3d9_helix.dll
;proxy_d3d11=d3d11_helix.dll


;------------------------------------------------------------------------------------------------------
; Settings to force display device to a specific mode.
; Uncomment a value to force the specific setting.
;------------------------------------------------------------------------------------------------------
[Device]

; overrides screen resolution.
;width=1280
;height=720

; overrides refresh rate set by game.
;refresh_rate=60

; filters available video modes to those providing given refresh rates.
; some games don't explicitely set the refresh rate, but use the video mode.
; use this if setting refresh_rate doesn't work.
;filter_refresh_rate=24,59,60

; forces creation of full screen devices and swap chains.
; use this for 3dtvplay if game won't active stereo mode.
; a value of 0 doesn't deactivate this option like on the others but
; forces the application into windowed mode.
;full_screen=1

; some games explicitely disable stereo, prohibiting any stereo attempts.
; settings this to 1 ignores all stereo disabling calls and also calls NvAPI_Stereo_Enable to force stereo on.
;force_stereo=1

; almost all DX11 games deactivate window message handling.
; setting this to 1 reenables print screen handling, alt-tab key handling etc.
;allow_windowcommands=1

; Indicates where the resolution is obtained for texture hashes. Comment this
; out to never special case hashes that match the resolution or a multiple.
; Possible values are swap_chain and depth_stencil. Recommended to test which
; works for a given game (e.g. CryEngine always creates a swap chain that
; matches the native resolution so has to use depth_stencil).
get_resolution_from = swap_chain


;------------------------------------------------------------------------------------------------------
; Settings for NVidia stereo driver.
;------------------------------------------------------------------------------------------------------
[Stereo]

; games which have their own stereo renderer disable the NVidia automatic
; stereo mode and render themselves into stereo buffers (Crysis 3 for example).
; Setting this to 1 disables the game stereo renderer and enables NVidia auto stereo mechanism.
; This also forces 'false' as a return for any request for NvAPI_Stereo_IsEnabled.
automatic_mode=0

; Some games (CryEngine games, for example) lock the separation to a specific
; value, which can be undesirable. Set this to 1 to ignore these requests from
; the game to unlock the separation:
unlock_separation=0

; games without predefined profiles can't save stereo settings.
; enabling this options automatically creates a profile for unknown games.
create_profile=0

; sets the global surface creation heuristic for NVidia stero driver.
; 0 = NVAPI_STEREO_SURFACECREATEMODE_AUTO - use driver registry profile settings for surface creation mode.
; 1 = NVAPI_STEREO_SURFACECREATEMODE_FORCESTEREO - Always create stereo surfaces.
; 2 = NVAPI_STEREO_SURFACECREATEMODE_FORCEMONO - Always create mono surfaces.
;surface_createmode=1

; overrides surface creation mode for square surfaces.
;surface_square_createmode=1

; Force the NvAPI_Initialize to return an error so that games think stereo and NVidia is unavailable.
force_no_nvapi=0


;------------------------------------------------------------------------------------------------------
; Settings for GPU manipulations.
; Render settings override
;------------------------------------------------------------------------------------------------------
[Rendering]

; GPU program manipulations.
;
; Shaders in game will be replaced by these custom shaders.
override_directory=ShaderFixes

; Automatically patched shaders will be written here if caching is enabled.
cache_directory=ShaderCache

; Shaders that are directly compiled by the game, instead of binary, go here.
storage_directory=ShaderFromGame

; cache all compiled .txt shaders into .bin. this removes loading stalls.
cache_shaders=1

; preload all patched shaders. there's a bug in NVidia auto stereoization if stereo shaders
; are being loaded during the game on some HW/SW combinations, which turns off auto patching
; for those stereo shaders (results in partial mono rendering). this is a workaround for this case.
preload_shaders=0

; thread save data structure access. required on multithreaded rendering.
use_criticalsection=1

; Setting this option disables scissor limits
rasterizer_disable_scissor=0

; Tracks copies and updates to textures which may cause their hash to become
; out of sync with their contents - enable if texture hashes seem unreliable:
track_texture_updates=1

;------------------------------------------------------------------------------------------------------
; Analyzation options.
;
; save all autofixed shaders as HLSL
export_fixed=0

; save all shaders sent to DX11 as ASM, or as HLSL text files if compiled by game.
export_shaders=0

; save all shaders seen as HLSL code, autofixed or not. 1= HLSL only, 2=HLSL+OriginalASM, 3=HLSL+OriginalASM+RecompiledASM
export_hlsl=0

; stores a ShaderUsage.txt file on any marking button press.
dump_usage=1

;------------------------------------------------------------------------------------------------------
; Automatic shader fixes. Those settings here apply only on newly read shaders.
; All existing *_replace.txt or *_replace.bin files are not tampered with.
; If you change settings here, the best workflow is to delete all shaders in
; the shader cache directory and let them be fixed again.

; Stereoize all shader parameters with position semantic.
fix_sv_position=0

; Pixel depth evaluation.
;fix_ZRepair_DepthTexture1=SceneDepthTexture.x
;fix_ZRepair_Dependencies1=MinZ_MaxZRatio
;fix_ZRepair_ZPosCalc1=zTex * MinZ_MaxZRatio.z - MinZ_MaxZRatio.w
;fix_ZRepair_DepthTexture2=SceneDepthTexture.x
;fix_ZRepair_Dependencies2=
;fix_ZRepair_ZPosCalc2=zTex
;fix_ZRepair_PositionTexture=PositionTexture
;fix_ZRepair_PositionCalc=1024 * %s

; Inject depth texture if other depth sources are unavailable.
;fix_ZRepair_DepthTextureHash=8a19f087b004598f

; Correct inverse transformations in pixel shaders using evaluated depth.
;fix_InvTransform=ScreenToLight,InverseTranslatedViewProjectionMatrix

; Back projection coordinate fix.
;
; Available variables in expressions:
; stereoParams.x = Separation value in range [0..1] or [-0..-1] dependent on active eye
; stereoParams.y = Convergence value in w coordinates (1/z)
; stereoParams.z = -1/1 for left/right eye
; stereoParams.w = Separation value without eye separation
; stereoTune.x = tune value 1 (default is 1)
; stereoTune.y = tune value 2 (default is 1)
; stereoTune.z = tune value 3 (default is 1)
; stereoTune.w = tune value 4 (default is 1)
; stereoScreenRes.x = Primary swap chain backbuffer horizontal resolution
; stereoScreenRes.y = Primary swap chain backbuffer vertical resolution
; zpos = current pixel z position in pixel shader
; wpos = current pixel w position in pixel shader

; Send inverse transformations from vertex shaders to pixel shaders.
;fix_BackProjectionTransform1=ScreenToTranslatedWorldMatrix._m00,ScreenToTranslatedWorldMatrix._m02,ScreenToTranslatedWorldMatrix._m01
;fix_BackProjectionTransform2=ScreenToWorld._m00,ScreenToWorld._m02,ScreenToWorld._m01

; Position variables to correct in pixel shaders.
;fix_ObjectPosition1=PointPositionAndInverseRadius
;fix_ObjectPosition1Multiplier=1, (stereoScreenRes.x/stereoScreenRes.y)*0.5, -0.5
;fix_ObjectPosition2=SpotPositionAndInverseRadius
;fix_ObjectPosition2Multiplier=1, (stereoScreenRes.x/stereoScreenRes.y)*0.5, -0.5

; Matrix multiplications to correct in pixel shaders.
;fix_MatrixOperand1=TranslatedWorldToShadowMatrix
;fix_MatrixOperand1Multiplier=1, (stereoScreenRes.x/stereoScreenRes.y)*0.5 - viewDirection.z*0.05 + (0.02791946-stereoParams.x/stereoParams.w), 0

; autofix shader option: recompiles all vertex shaders. fixes minor differences in deferred rendering.
;recompile_all_vs=0

;------------------------------------------------------------------------------------------------------
; Shader manipulations without patches + shader filtering.
;------------------------------------------------------------------------------------------------------
;[ShaderOverride1]
;Hash=69732c4f23cb6c48
; Custom stereo separation value while rendering objects using this shader.
;Separation=0
; Custom stereo convergence value while rendering objects using this
; shader (e.g. convergence=0 will move an object to infinity).
;Convergence=0
; don't draw anything using this shader.
;Handling=skip
; advanced option: use this to override only if this shader is used rendering the given index buffer.
;IndexBufferFilter=b3e56ebc
; Use replaced shader only when there is no active depth buffer (for UI filtering)
;depth_filter = depth_inactive
; Use replaced shader only when there *IS* an active depth buffer (for UI filtering)
;depth_filter = depth_active
; Only use replaced shader when it is used in conjunction with a specific shader
; (e.g. to adjust a vertex shader ONLY when it is used with a specific pixel shader)
;partner=af7b880f07630615
; Assignes a dummy render target to o0. Use to fix one-eye rendering issues in
; shaders that only write to a depth target:
;fake_o0=1
; Override a value from [Constants] when this shader is used:
;x=2.0
; Pass the dimensions of the active render target and resolution (obtained with
; get_resolution_from) into the shader:
;x1=rt_width
;y1=rt_height
;z1=res_width
;w1=res_height
; Use t0 from active pixel shader for texture filtering. Will be 0 if no
; [TextureOverride*] section exists for the texture or 1 if one does. For advanced
; filtering, set a value for filter_index in the [TextureOverride] section.
;x2=ps-t0
; There's also support for copying textures, constant buffers, depth buffers,
; etc. from one shader to another. This is a complex topic - see this page:
;    https://github.com/bo3b/3Dmigoto/wiki/Resource-Copying


; Filter weapon sight adjustment so that it only applies when there is no
; active depth buffer - avoids adjustments to other objects in the world.
; e.g. lightbulbs, halo on water to either side of boats, etc.
[ShaderOverrideWeaponSight]
; Red dot / triangle sight, sniper scope
Hash=765c3e296da52533
depth_filter = depth_inactive
vs-t110 = ResourceZBuffer

[ShaderOverrideWeaponSight2]
; Recurve Bow sight
Hash = d7e9145d999432c7
depth_filter = depth_inactive
vs-t110 = ResourceZBuffer

[ShaderOverrideHudAndSniperLaser]
; Filter to avoid messing up enemy sniper lasers
Hash = ba19f0c9ae1d7486
depth_filter = depth_inactive

[ShaderOverrideSunMoonGlow]
; Need to do different things depending on which render target is in use.
; Pass the render target size and screen resolution into the shader to for filtering.
Hash = efce02356807ae1b
x1=rt_width
y1=rt_height
z1=res_width
w1=res_height

;[ResourceWBuffer]
;max_copies_per_frame = 1

[ResourceZBuffer]
max_copies_per_frame = 1
[ResourceZBufferLastFrame]

[ResourceCViewportShaderParameterProvider]

[ResourceFixNoAAShadowSyncIssue]

[Present]
;ResourceWBuffer = null
ResourceZBufferLastFrame = ref ResourceZBuffer
ResourceZBuffer = null
ResourceFixNoAAShadowSyncIssue = null
; W marks that ResourceZBuffer has been copied this frame:
w = 0
; W2 marks that the camera HUD or mission text is being drawn in the frame:
w2 = 0
; x3 indicates that the repair tool has been drawn this frame:
x3 = 0
; w3 indicates that the climbing rope is NOT being drawn:
w3 = 1
; Uncomment to enable a custom shader that allows the stereo output mode to be
; changed to Side-by-Side or Top-and-Bottom:
;run = CustomShader3DVision2SBS

; Non-AA directional lighting shaders
;
; Using Frame analysis, I was able to determine the cause of the 1 frame sync
; issue with shadows when Anti-aliasing is disabled (or SMAA). The shadows are
; rendered fine, but the pass that copies them to the screen uses the buffer
; from the previous frame. This is a game bug, but we can use the arbitrary
; resource copying support in 3DMigoto to copy the correct buffer ourselves to
; fix it.
[ShaderOverrideDirectionalShadowsNoAAHigh]
Hash = 149c09dd3792cebb
post ResourceFixNoAAShadowSyncIssue = o0
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverrideDirectionalShadowsNoAAVeryHigh]
Hash = b674b00500663d60
post ResourceFixNoAAShadowSyncIssue = o0
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverrideDirectionalShadowsNoAASoft]
Hash = 7f6a827ab54982d8
post ResourceFixNoAAShadowSyncIssue = o0
ResourceCViewportShaderParameterProvider = ref ps-cb0
; [ShaderOverridePhysicalLightingNoAAHighVegetation] moved below with other physical lighting shaders

; AA directional lighting shaders
;
; In the case of AA lighting shaders we can't get the depth buffer because we
; can't resolve it into a non-AA texture, and the crosshair shader is SM4 which
; can't sample an MSAA texture. We still grab the viewport constant buffer
; though, which we need to scale the depth. Have to use the PS hashes to
; distinguish these from the non-AA variants
[ShaderOverrideDirectionalShadowsAA2High]
Hash = 78fedf913827866d
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverrideDirectionalShadowsAA2VeryHigh]
Hash = ac5fba3d4b543796
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverrideDirectionalShadowsAA2Soft]
Hash = 03232d48bca270a2
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverrideDirectionalShadowsAA4High]
Hash = e32db13a74674ed9
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverrideDirectionalShadowsAA4VeryHigh]
Hash = ed7c22bb8f7fa4e6
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverrideDirectionalShadowsAA4Soft]
Hash = 6b3342526a5ce50b
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverrideDirectionalShadowsAA8High]
Hash = c4c278db36f2feeb
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverrideDirectionalShadowsAA8VeryHigh]
Hash = b5b9d247af1d66fb
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverrideDirectionalShadowsAA8Soft]
Hash = b7f7ad62461f55c0
ResourceCViewportShaderParameterProvider = ref ps-cb0

; More lights to make sure we still can get the viewport params in caves, etc
; when directional lighting is disabled
[ShaderOverridePhysicalLightingNoAAMediumVegetation]
Hash = 18d84611abd87606
ps-t10 = ResourceFixNoAAShadowSyncIssue unless_null
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLightingNoAAHighVegetation]
Hash = 6d82ce75a16feb83
ps-t10 = ResourceFixNoAAShadowSyncIssue unless_null
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting3]
Hash = d4e77294d5c49a53
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting4]
Hash = aa0ba3aefd2413b1
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting5]
Hash = 8afc461f52eab3e6
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting6]
Hash = 26d2628c45dfbeea
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting7]
Hash = bae6b98bfda33066
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting8]
Hash = c73430e1895ff2f8
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting9]
Hash = ea7ccc99799c7228
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting10]
Hash = 54eae19b7f5cc5a0
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting11]
Hash = 6ee0d5531150d4cd
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting12]
Hash = d120ec3d6d0ad200
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting13]
Hash = 343df1da0e3edd9e
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting14]
Hash = 9a9b807b3669906a
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting15]
Hash = 8870ff9827077a28
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting16]
Hash = 40fdd63f0d945497
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting17]
Hash = 21bb80dc29b691bb
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting18]
Hash = 01f23eabdd55a4de
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting19]
Hash = 5b0fcbe11dff7344
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting20]
Hash = 5059cf988234568b
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting21]
Hash = 325594ab3056df53
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting22]
Hash = f22672f7d2f3e4d5
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting23]
Hash = 72a6e709c250e563
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting24]
Hash = ef62df7b760ff261
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting25]
Hash = 375c5401a4ad4241
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting26]
Hash = 775ad5671fae6770
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting27]
Hash = 8a508f9327f97cf3
ResourceCViewportShaderParameterProvider = ref ps-cb0
[ShaderOverridePhysicalLighting28]
Hash = dd3d62e85908f373
ResourceCViewportShaderParameterProvider = ref ps-cb0


; Late shaders that copy the non-AA depth buffer / resolve the AA depth buffer
; to their output with no scaling applied. Can't find any settings these are
; conditional on, so hopefully we can rely on them. Use the vertex shader
; hashes so we don't need every AA hash.
[ShaderOverrideDepthNoAA]
Hash = 93351bc8c3e6bac3
;PS Hash = 11b40b7f902ffda9
post ResourceZBuffer = stereo2mono o0
w = 1
[ShaderOverrideDepthMSAA2]
Hash = f94492b144b195f5
;PS Hash for MSAA2 = da5bc632d34d55fb
;PS Hash for MSAA4 = 013367696a98ac22
post ResourceZBuffer = stereo2mono o0
w = 1

; The HBAO+ shaders pre-scale the depth buffer to a W buffer, eliminating the
; need to do any scaling in the HUD shaders. However, these are only used when
; HBAO+ is enabled, so we can't rely on them.
; [ShaderOverrideZToWBuffer_HBAO_NoAA]
; Hash = 170486ed36efcc9e
; post ResourceWBuffer = o0
; [ShaderOverrideZToWBuffer_HBAO_AA]
; Hash = 9e068d85957198d9
; post ResourceWBuffer = o0


; Broken HBAO+ shaders. These create view-space coordinates, so they need the
; projection or inverse projection matrix to fix accurately independently of
; the FOV.
[ShaderOverrideHBAOBrokenPass1]
Hash = 0e574bd62c0201de
ps-cb13 = ResourceCViewportShaderParameterProvider
[ShaderOverrideHBAOBrokenPass2]
Hash = 9a56848a2b205209
ps-cb13 = ResourceCViewportShaderParameterProvider


[ResourceHUDMask]
filename = ShaderFixes\hud-mask.png

[ResourceHUDIconFilter1]
filename = ShaderFixes\82efdcb5-icon-filter.png

[ResourceHUDIconFilter2]
filename = ShaderFixes\b5c2f686-icon-filter.png

[ShaderOverrideCrosshairMapAndIcons]
Hash = 50344260ea3c9a9c
x2 = ps-t0

; Used to detect the camera HUD across multiple draw calls:
checktextureoverride = ps-t0

; vs-t110 = ResourceWBuffer
vs-t110 = ResourceZBuffer
vs-cb13 = ResourceCViewportShaderParameterProvider
; Do not use cb12 - I wasted hours wondering what I was doing wrong, and
; eventually I found cb12[0].x is > 0 in one eye and < 0 in the other! I think
; I may have found where 3D Vision injects the stereo parameters (didn't even
; know constant buffers could be stereoised)!
;vs-cb12 = vb0
; We can pass the vertex buffer into a constant buffer slot, but that means we
; need to manually calculate the offsets of any information we need, which is
; doable, but not straight forward:
;vs-cb11 = vb0
; This copies the vertex buffer into the shader as a structured buffer,
; allowing us to look up the position of any vertex we want very easily:
vs-t100 = vb0
z2 = vertex_count
z1=res_width
w1=res_height
vs-t101 = ResourceHUDIconFilter1
vs-t102 = ResourceHUDIconFilter2
vs-t105 = ResourceHUDMask

[TextureOverrideMapVignette1]
; Use full screen stretch adjustment for vignette around the map
Hash = a2777da7
filter_index = 2
[TextureOverrideMapVignette2]
Hash = 93bbac0a
filter_index = 2

[TextureOverrideCrosshairAndIcons]
; Crosshair, but unfortunately also some other icons
Hash=82efdcb5
filter_index = 3
[TextureOverrideIconSheet2]
; Lots of icons, including most of the floating ones as well as others
Hash=b5c2f686
filter_index = 5

[TextureOverrideCrosshairRocketLauncherCircle]
Hash=3e6e474b
filter_index = 4
[TextureOverrideCrosshairRocketLauncherDiamond]
; Not really supposed to be centered on the screen, but this way it lines up
; with the rest of the targetting disaplay on this weapon + sight.
Hash=54d1e89a
filter_index = 4

[TextureOverrideCameraVignette]
Hash=e5a53b70
; Different filter index to tell the HUD shader to stretch it back to
; fullscreen:
filter_index = 7
[TextureOverrideCameraCross]
Hash=4f74d339
filter_index = 4
; Mark that the camera HUD is being drawn
w2 = 1
[TextureOverrideCameraCircle]
Hash=4b821638
filter_index = 4
[TextureOverrideCameraCross1]
Hash=d7c10c1e
filter_index = 4
[TextureOverrideCameraSquare]
Hash=1fdb7351
filter_index = 4
[TextureOverrideCameraSquare1]
Hash=dacfdad5
filter_index = 4
[TextureOverrideCameraCrosshairHighlight]
; This is a pure white texture - it affects other things such as the
; exclamation marks on the DLC items on the main menu. We mark this with a
; separate texture filter index to the other camera shaders, and use the fact
; that w2 has been set earlier in TextureOverrideCameraCross to detect that it
; is the camera.
Hash=dbb19057
filter_index = 6

[TextureOverrideMissionHindiText]
Hash=a4758cc8
; Mark that the mission text is being displayed to disable auto icon
; adjustments:
w2 = 2

[ShaderOverrideTextMinimapBackground]
Hash = 2acbe5d8a9036288
vs-t110 = ResourceZBuffer
vs-cb13 = ResourceCViewportShaderParameterProvider
vs-t100 = vb0
z2 = vertex_count
[ShaderOverrideTextPS]
Hash = e5f97b65ba28c3a8
y2 = 2
post y2 = 0
[ShaderOverrideMinimapBackgroundPS]
Hash = 3b07ae96a17d2526
y2 = 3
post y2 = 0

[ShaderOverrideMinimapBox]
Hash = 7da5ae77ebbf57bd
vs-t110 = ResourceZBuffer
vs-cb13 = ResourceCViewportShaderParameterProvider

[ShaderOverrideNVSoftShadows]
; NVIDIA soft shadows already support 3D Vision, but it was not hooked up in
; this game. Simply copy the 3DMigoto stereo sampler into the texture slot the
; shader expects and BAM - soft shadows work flawlessly, no replaced shader
; required :)
hash = dad3c3818c805cc3
ps-t5 = ps-t125

;------------------------------------------------------------------------------------------------------
; texture / render target manipulations
;------------------------------------------------------------------------------------------------------
;
; NOTE: If you are trying to match a texture the same size as the resolution (or
; a /2, x2, x4 or x8 multiple), you should confirm that the same hash is used
; on different resolutions, and adjust get_resolution_from if necessary.
;
;[TextureOverride1]
;Hash=c3e55ebd
; NVidia stores surface creation mode heuristics in the game profile. setting
; this option overrides the creation mode for a given texture / buffer.
; 0 = NVAPI_STEREO_SURFACECREATEMODE_AUTO - use driver registry profile settings.
; 1 = NVAPI_STEREO_SURFACECREATEMODE_FORCESTEREO - create stereo surface.
; 2 = NVAPI_STEREO_SURFACECREATEMODE_FORCEMONO - create mono surface.
;StereoMode=2

;[TextureOverride2]
;Hash = e27b9d07
; Prevent the game reading from this texture - will give the game a blank
; buffer instead. Used to prevent CryEngine games falsely culling objects. Use
; debug logging and look for Map calls to identify possible hashes.
;deny_cpu_read=1
; Expand the region copied to this texture with CopySubresourceRegion (similar
; issue to rasterizer_disable_scissor). Used to solve issues with transparent
; refraction effects (like glass) in CryEngine games.
;expand_region_copy=1


; Force water reflections to render in stereo

[TextureOverrideLowQualityWaterReflection]
; <RenderTarget hash=c8a3237e type=Texture2D Width=640 Height=360 MipLevels=3 ArraySize=1 RawFormat=9 Format="R16G16B16A16_TYPELESS" SampleDesc.Count=1 SampleDesc.Quality=0 Usage=0 BindFlags=40 CPUAccessFlags=0 MiscFlags=0></RenderTarget>
Hash = c8a3237e
StereoMode = 1

[TextureOverrideLowQualityWaterReflectionDepth]
; <DepthTarget hash=bf1bf94a type=Texture2D Width=640 Height=360 MipLevels=1 ArraySize=1 RawFormat=19 Format="R32G8X24_TYPELESS" SampleDesc.Count=1 SampleDesc.Quality=0 Usage=0 BindFlags=72 CPUAccessFlags=0 MiscFlags=0></DepthTarget>
hash = bf1bf94a
StereoMode = 1

[TextureOverrideMediumHighQualityWaterReflection]
; <RenderTarget hash=c7e4d804 type=Texture2D Width=512 Height=512 MipLevels=3 ArraySize=1 RawFormat=9 Format="R16G16B16A16_TYPELESS" SampleDesc.Count=1 SampleDesc.Quality=0 Usage=0 BindFlags=40 CPUAccessFlags=0 MiscFlags=0></RenderTarget>
hash=c7e4d804
StereoMode = 1

[TextureOverrideMediumHighQualityWaterReflectionDepth]
; <DepthTarget hash=b05c0230 type=Texture2D Width=512 Height=512 MipLevels=1 ArraySize=1 RawFormat=19 Format="R32G8X24_TYPELESS" SampleDesc.Count=1 SampleDesc.Quality=0 Usage=0 BindFlags=72 CPUAccessFlags=0 MiscFlags=0></DepthTarget>
hash=b05c0230
StereoMode = 1

[TextureOverrideUltraQualityWaterReflection]
; <RenderTarget hash=660ebd75 type=Texture2D Width=1024 Height=1024 MipLevels=3 ArraySize=1 RawFormat=9 Format="R16G16B16A16_TYPELESS" SampleDesc.Count=1 SampleDesc.Quality=0 Usage=0 BindFlags=40 CPUAccessFlags=0 MiscFlags=0></RenderTarget>
hash=660ebd75
StereoMode = 1

[TextureOverrideUltraQualityWaterReflectionDepth]
; <DepthTarget hash=11b66741 type=Texture2D Width=1024 Height=1024 MipLevels=1 ArraySize=1 RawFormat=19 Format="R32G8X24_TYPELESS" SampleDesc.Count=1 SampleDesc.Quality=0 Usage=0 BindFlags=72 CPUAccessFlags=0 MiscFlags=0></DepthTarget>
hash=11b66741
StereoMode = 1



; Force weapon previews in shop to mono since the left eye is never cleared
; Uses get_resolution_from=swap_chain to special case these textures hashes being 2 x resolution
[TextureOverrideWeaponPreview]
; <RenderTarget hash=2d6d9e98 type=Texture2D Width=3840 Height=2160 MipLevels=1 ArraySize=1 RawFormat=90 Format="B8G8R8A8_TYPELESS" SampleDesc.Count=1 SampleDesc.Quality=0 Usage=0 BindFlags=40 CPUAccessFlags=0 MiscFlags=0></RenderTarget>
; <RenderTarget hash=2d6d9e98 type=Texture2D Width=2560 Height=1440 MipLevels=1 ArraySize=1 RawFormat=90 Format="B8G8R8A8_TYPELESS" SampleDesc.Count=1 SampleDesc.Quality=0 Usage=0 BindFlags=40 CPUAccessFlags=0 MiscFlags=0></RenderTarget>
hash=2d6d9e98
StereoMode = 2
[TextureOverrideWeaponPreviewDepth]
; <DepthTarget hash=ccf295fb type=Texture2D Width=3840 Height=2160 MipLevels=1 ArraySize=1 RawFormat=19 Format="R32G8X24_TYPELESS" SampleDesc.Count=1 SampleDesc.Quality=0 Usage=0 BindFlags=72 CPUAccessFlags=0 MiscFlags=0></DepthTarget>
; <DepthTarget hash=ccf295fb type=Texture2D Width=2560 Height=1440 MipLevels=1 ArraySize=1 RawFormat=19 Format="R32G8X24_TYPELESS" SampleDesc.Count=1 SampleDesc.Quality=0 Usage=0 BindFlags=72 CPUAccessFlags=0 MiscFlags=0></DepthTarget>
hash=ccf295fb
StereoMode = 2

; The following custom shader can convert 3D Vision to Side-by-Side and
; Top-and-Bottom for use with 3D TVs & projectors - to enable this uncomment
; the 'run = CustomShader3DVision2SBS' in the [Present] section, set 3D Vision
; to output "checkerboard" in the control panel (which will remove the 720p
; limitation) and enable this either via the F9 key, or by setting a default
; for x7 in the [Constants] section.
[Resource3DVision2SBSBackupTexture]
[CustomShader3DVision2SBS]
; Load a custom vertex + pixel shader:
vs = ShaderFixes/3dvision2sbsvs.hlsl
ps = ShaderFixes/3dvision2sbsps.hlsl
; Explicitly unbind other shader types for safety:
hs = null
ds = null
gs = null
; Disable the OM blend stage that could interfere with the shader:
blend = disable
; Disable front/back face culling so the vertices can be in any rotation:
cull = none
; Use a triangle strip topology so we only have to output four vertices:
topology = triangle_strip
; Clear all render + depth targets to avoid compatibility issues:
o1 = null
o2 = null
o3 = null
o4 = null
o5 = null
o6 = null
o7 = null
oD = null
; Bind the back buffer as a render target. set_viewport ensures that the view
; port is the size of the buffer so the draw call will work, and no_view_cache
; is necessary for a few games like Mad Max:
o0 = set_viewport no_view_cache bb
; Back up any textures that were in the ps-t100 slot. The CustomResource
; section will already back up a lot of state, including shaders, render
; targets, depth targets, UAVs, viewports, blend state, rasterizer state,
; primitive topology, etc. but it does not back up textures:
Resource3DVision2SBSBackupTexture = reference ps-t100
; Use the reverse stereo blit to give the shader access to the back buffers of
; both eyes:
ps-t100 = stereo2mono bb
; Draw four vertices. The vertex shader will construct coordinates to cover the
; full screen using the SV_VertexID semantic so we don't need vertex buffers:
draw = 4, 0
; Restore the original texture from the ps-t100 slot:
post ps-t100 = reference Resource3DVision2SBSBackupTexture

[KeyChange3DVision2SBSOutputMode]
key = F9
; 0 = Regular 3D Vision
; 1 = Reversed 3D Vision
; 2 = Side by Side
; 3 = Reversed Side by Side
; 4 = Top and Bottom
; 5 = Reversed Top and Bottom
x7 = 1, 2, 3, 4, 5, 0
type = cycle
