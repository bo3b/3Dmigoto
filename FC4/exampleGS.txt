// Straight out of msdn, but of course it won't even compile, with missing variables.
// And ten warnings after that.

struct GSPS_INPUT
{
    float4 Pos : SV_POSITION;
    float3 Norm : TEXCOORD0;
    float2 Tex : TEXCOORD1;
};

[maxvertexcount(12)]
void main( triangle GSPS_INPUT input[3], inout TriangleStream<GSPS_INPUT> TriStream )
{
    GSPS_INPUT output;
    float4x4 View= {
	{1, 0, 0, 0},
	{0, 1, 0, 0},
	{0, 0, 1, 0},
	{0, 0, 0, 1}
};
    float4x4 Projection= {
	{1, 0, 0, 0},
	{0, 1, 0, 0},
	{0, 0, 1, 0},
	{0, 0, 0, 1}
};
    
    //
    // Calculate the face normal
    //
    float3 faceEdgeA = input[1].Pos - input[0].Pos;
    float3 faceEdgeB = input[2].Pos - input[0].Pos;
    float3 faceNormal = normalize( cross(faceEdgeA, faceEdgeB) );
    float3 ExplodeAmt = faceNormal;//*Explode;
    
    //
    // Calculate the face center
    //
    float3 centerPos = (input[0].Pos.xyz + input[1].Pos.xyz + input[2].Pos.xyz)/3.0;
    float2 centerTex = (input[0].Tex + input[1].Tex + input[2].Tex)/3.0;
    centerPos += faceNormal;//*Explode;
    
    //
    // Output the pyramid
    //
    for( int i=0; i<3; i++ )
    {
        output.Pos = input[i].Pos + float4(ExplodeAmt,0);
        output.Pos = mul( output.Pos, View );
        output.Pos = mul( output.Pos, Projection );
        output.Norm = input[i].Norm;
        output.Tex = input[i].Tex;
        TriStream.Append( output );
        
        int iNext = (i+1)%3;
        output.Pos = input[iNext].Pos + float4(ExplodeAmt,0);
        output.Pos = mul( output.Pos, View );
        output.Pos = mul( output.Pos, Projection );
        output.Norm = input[iNext].Norm;
        output.Tex = input[iNext].Tex;
        TriStream.Append( output );
        
        output.Pos = float4(centerPos,1) + float4(ExplodeAmt,0);
        output.Pos = mul( output.Pos, View );
        output.Pos = mul( output.Pos, Projection );
        output.Norm = faceNormal;
        output.Tex = centerTex;
        TriStream.Append( output );
        
        TriStream.RestartStrip();
    }
    
    for( int i=2; i>=0; i-- )
    {
        output.Pos = input[i].Pos + float4(ExplodeAmt,0);
        output.Pos = mul( output.Pos, View );
        output.Pos = mul( output.Pos, Projection );
        output.Norm = -input[i].Norm;
        output.Tex = input[i].Tex;
        TriStream.Append( output );
    }
    TriStream.RestartStrip();
}


/***** example ASM from above code:

Microsoft (R) Direct3D Shader Compiler 6.3.9600.16384
Copyright (C) 2013 Microsoft. All rights reserved.

//
// Generated by Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float   xyzw
// TEXCOORD                 0   xyz         1     NONE   float   xyz 
// TEXCOORD                 1   xy          2     NONE   float   xy  
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float   xyzw
// TEXCOORD                 0   xyz         1     NONE   float   xyz 
// TEXCOORD                 1   xy          2     NONE   float   xy  
//
gs_4_0
dcl_input_siv v[3][0].xyzw, position
dcl_input v[3][1].xyz
dcl_input v[3][2].xy
dcl_temps 4
dcl_inputprimitive triangle 
dcl_outputtopology trianglestrip 
dcl_output_siv o0.xyzw, position
dcl_output o1.xyz
dcl_output o2.xy
dcl_maxout 12
add r0.xyz, -v[0][0].zxyz, v[1][0].zxyz
add r1.xyz, -v[0][0].yzxy, v[2][0].yzxy
mul r2.xyz, r0.xyzx, r1.xyzx
mad r0.xyz, r0.zxyz, r1.yzxy, -r2.xyzx
dp3 r0.w, r0.xyzx, r0.xyzx
rsq r0.w, r0.w
mul r0.xyz, r0.wwww, r0.xyzx
add r1.xyz, v[1][0].xyzx, v[0][0].xyzx
add r1.xyz, r1.xyzx, v[2][0].xyzx
add r2.xy, v[1][2].xyxx, v[0][2].xyxx
add r2.xy, r2.xyxx, v[2][2].xyxx
mul r2.xy, r2.xyxx, l(0.333333, 0.333333, 0.000000, 0.000000)
add r3.xyz, r0.xyzx, r0.xyzx
mad r1.xyz, r1.xyzx, l(0.333333, 0.333333, 0.333333, 0.000000), r3.xyzx
mov r0.w, l(0)
mov r1.w, l(0)
loop 
  ige r2.z, r1.w, l(3)
  breakc_nz r2.z
  add r3.xyzw, r0.xyzw, v[r1.w + 0][0].xyzw
  mov o0.xyzw, r3.xyzw
  mov o1.xyz, v[r1.w + 0][1].xyzx
  mov o2.xy, v[r1.w + 0][2].xyxx
  emit 
  iadd r1.w, r1.w, l(1)
  udiv null, r2.z, r1.w, l(3)
  add r3.xyzw, r0.xyzw, v[r2.z + 0][0].xyzw
  mov o0.xyzw, r3.xyzw
  mov o1.xyz, v[r2.z + 0][1].xyzx
  mov o2.xy, v[r2.z + 0][2].xyxx
  emit 
  mov o0.xyz, r1.xyzx
  mov o0.w, l(1.000000)
  mov o1.xyz, r0.xyzx
  mov o2.xy, r2.xyxx
  emit 
  cut 
endloop 
mov r0.w, l(0)
mov r1.x, l(2)
loop 
  ilt r1.y, r1.x, l(0)
  breakc_nz r1.y
  add r2.xyzw, r0.xyzw, v[r1.x + 0][0].xyzw
  mov o0.xyzw, r2.xyzw
  mov o1.xyz, -v[r1.x + 0][1].xyzx
  mov o2.xy, v[r1.x + 0][2].xyxx
  emit 
  iadd r1.x, r1.x, l(-1)
endloop 
cut 
ret 
// Approximately 52 instruction slots used
*/